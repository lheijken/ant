#pragma once

/** @page expconfig Experimental configuration
 *
 * This part represents the experimental config, including the feature to
 * automatically search and find an appropiate experimental config based on
 * ant::TID or on the name of a setup.
 *
 */

#include "base/Detector_t.h"
#include "reconstruct/Reconstruct_traits.h"
#include "calibration/Calibration.h"
#include "base/piecewise_interval.h"

#include <memory>
#include <list>
#include <map>

namespace ant {

struct TID;

namespace expconfig {
class Setup_traits;
} // keep ExpConfig itself in ant namespace

class ExpConfig
{
public:

    class Setup {
    public:

        /**
         * @brief Get returns the currently set setup
         * @return the Setup_traits instance, see also GetByType if specific cast is needed
         * @throws ExceptionNoSetup if no setup if found (see also SetByName and SetByTID)
         */
        static const expconfig::Setup_traits& Get();

        /**
         *  @brief the templated version of Get() for specialized setups (typically used by unpackers)
         */
        template<typename SetupType>
        static const SetupType& GetByType();

        /**
         * @brief GetDetector ask for detector by type
         * @param type the requested type
         * @return detector pointer, never nullptr
         * @throws ExceptionNoDetector if no detector was found
         * @see the templated version to get type-safe detector
         */
        static std::shared_ptr<Detector_t> GetDetector(Detector_t::Type_t type);

        /**
         * @brief the templated version of GetDetector() for specialized detectors,
         * @example Use as GetDetector<TaggerDetector_T>() to obtain tagger in setup
         * @throws ExceptionNoDetector if no detector is found
         */
        template<typename DetectorType>
        static std::shared_ptr<DetectorType> GetDetector();

        /**
         * @brief SetByName override current setup to this name, SetByTID won't have any effect then
         * @param setupname the setup's name
         * @throws ExceptionNoSetup if no setup was found with that name
         */
        static void SetByName(const std::string& setupname);

        /**
         * @brief SetByTID automatically search setup by using their Matches() method
         * @param tid TID for searching (usually provided/generated by unpacker)
         */
        static void SetByTID(const TID& tid);

        static std::list<std::string> GetNames();
        static void Cleanup();

        Setup() = delete; // this class is more a wrapper for handling the setup

    private:
        using SetupPtr = std::shared_ptr<const expconfig::Setup_traits>;
        static std::string manualName;
        static SetupPtr currentSetup;
    };

    class Exception : public std::runtime_error {
        using std::runtime_error::runtime_error; // use base class constructor
    };
    class ExceptionNoSetup : public Exception {
        using Exception::Exception;
    };
    class ExceptionNoDetector : public Exception {
        using Exception::Exception;
    };
    ExpConfig() = delete; // this class is more a wrapper for handling the config

};

// forward declare for Setup_traits interface
struct Updateable_traits;
namespace calibration {
class DataManager;
}

namespace expconfig {

/**
 * @brief The Setup_traits class is the interface to the "static" experimental information
 */
class Setup_traits {
public:
    virtual bool Matches(const TID& header) const = 0;

    virtual std::string GetName() const = 0;
    virtual double GetElectronBeamEnergy() const = 0;
    virtual std::list< std::shared_ptr< Calibration::PhysicsModule> > GetCalibrations() const = 0;
    virtual std::string GetPIDCutsDirectory() const = 0;
    virtual std::string GetPhysicsFilesDirectory() const = 0;
    virtual std::shared_ptr<calibration::DataManager> GetCalibrationDataManager() const = 0;

    virtual std::list< std::shared_ptr< ReconstructHook::Base > > GetReconstructHooks() const = 0;
    virtual std::list< std::shared_ptr< Detector_t > > GetDetectors() const = 0;
    virtual std::list< std::shared_ptr< Updateable_traits> > GetUpdateables() const = 0;

    struct candidatebuilder_config_t {
        /// @see ant::reconstruct::CandidateBuilder::PID_phi_epsilon
        double PID_Phi_Epsilon = 0.0;      // in Rad
        double CB_ClusterThreshold = 15;   // in MeV
        double TAPS_ClusterThreshold = 20; // in MeV
        candidatebuilder_config_t() = default;
    };

    virtual candidatebuilder_config_t GetCandidateBuilderConfig() const {
        return candidatebuilder_config_t();
    }

    struct triggersimu_config_t {
        enum class Type_t {
            Unknown,
            CBESum,
            // may add CBESumTapsMult, or similar
        };

        // defaults are set to nothing specific
        Type_t Type = Type_t::Unknown;

        // for CBESum simulation on MC
        double CBESum_Edge  = std_ext::NaN;
        double CBESum_Width = std_ext::NaN;
        std::vector<unsigned> CBESum_MissingElements; // sometimes the analog sum does not include all elements

        // may add more fields, for example to specify TAPS multiplicity
    };

    virtual triggersimu_config_t GetTriggerSimuConfig() const {
        return triggersimu_config_t();
    }

    virtual bool GetIncludeIgnoredElements() const = 0;
    virtual ant::PiecewiseInterval<double> GetPromptWindows() const = 0;
    virtual ant::PiecewiseInterval<double> GetRandomWindows() const = 0;

    virtual ~Setup_traits() = default;

}; // Setup_traits

} // namespace ant::expconfig


// templated static getters can now be implemented,
// as Setup_traits is now defined

template<typename DetectorType>
std::shared_ptr<DetectorType> ExpConfig::Setup::GetDetector()
{
    auto& setup = Get();
    for(const auto& detector : setup.GetDetectors()) {
        auto detector_ = std::dynamic_pointer_cast<DetectorType, Detector_t>(detector);
        if(detector_ != nullptr)
            return detector_;
    }
    throw ExceptionNoDetector("Could not find detector "+
                              std_ext::getTypeAsString<DetectorType>()+" in given setup");
}

template<typename SetupType>
const SetupType& ExpConfig::Setup::GetByType()
{
    if(!currentSetup)
        throw ExceptionNoSetup("No setup specified at all");
    try {
        return dynamic_cast<const SetupType&>(*currentSetup);
    }
    catch(std::bad_cast&) {
        throw ExceptionNoSetup("Requested setup does not implement type");
    }
    throw Exception("Unknown error occurred in ExpConfig::Setup::GetByType()");
}



} // namespace ant
